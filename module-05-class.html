<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 5 Class</title>
<style>* { font-family: monospace; }</style>
<script>
//--------------------------------//
// The linked list data structure //
//--------------------------------//
console.log("The linked list data structure");

// 1. Suppose you have an array with 1,000 elements and a linked list with 1,000
//    elements. For both data structures, you want to retrieve the last entry.
//    Does one data structure complete that operation before the other (i.e.,
//    is it faster)? If yes, how much faster? If no, why does it take the same
//    amount of time?
 // Yes, one data structure may be faster at completing an operation than another. It depends on the specific data structures and operations involved.
 


//------------------------//
// Creating a linked list //
//------------------------//
console.log("Creating a linked list");

// We are going to implement the linked list data structure described in the
// book. Instead of using 'let' we use 'var' everywhere. Note that this
// implementation does not use the prototype (see homework). Here is a skeleton
// that we will work on completing:

function LinkedList() {

  // helper class
  function Node(element) {
    this.element = element;
    this.next = null;
  }

  // store length and head
  var length = 0;
  var head = null;

  this.append = function(element) {
    // add a new item to the end of the list
    //   var node = {
      element: element,
        next: null
    };
    if (this.head === null) {
        this.head = node;
    } else {
        var current = this.head;
        while (current.next) {
            current = current.next;
        }
        current.next = node;
    }
    this.length++;
};

this.append = function(
  };

  this.insert = function(position, element) {
    // insert a new item at a specific location
       if (position >= 0 && position <= this.length) {
      var node = {
            element: element,
            next: null
        };
        var current = this.head;
        var previous = null;
        var index = 0;

        if (position === 0) { // first item
            node.next = current;
            this.head = node;
        } else {
            while (index++ < position)
  };

  this.removeAt = function(position) {
    // remove an element from a specific location
     if (position === 0) { // first item
  };

  this.remove = function(element) {
    // remove a specific element from the list
    
  };

  this.indexOf = function(element) {
    // return the index of an element in the list
    
  };

  this.isEmpty = function() {
    // check whether the list is empty
    function isEmpty(arr) {
  return arr.length === 0;
}
  };

  this.size = function() {
    // return the number of elements in the list
    function node(arr, el) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === el) {
      return i;
    }
  }
}
  };

  this.getHead = function() {
    // return head node
    // ...
  }

  this.toString = function() {
    // overwrite the default toString method
    var current = head;
    var string = "List: ";
    while (current) {
      string += current.element + (current.next ? " -> " : "");
      current = current.next;
    }
    return string;
  };

  this.print = function() {
    // print to the console
    console.log(this.toString());
  };

}

// create a linked list to operate on
var list = new LinkedList();

// 1. Write pseudo code to describe how you would
//    implement the append method. HINT: What two scenarios can you distinguish?
function append(list, item) {
    // create a new node with the given item
    var newNode = {
        item: item,
        next: null
    };

    // if the list is empty, make the new node the first node
    if (list.first === null) {
        list.first = newNode;
    }
    // otherwise, attach the new node to the end of the list
    else {;
// 2. Translate your pseudo code into actual code and test it.
//    HINT: Use list.print() to test your code.

// 3. Repeat (1) and (2) for insert.

// 4. Repeat (1) and (2) for removeAt.

// 5. Repeat (1) and (2) for remove.

// 6. Repeat (1) and (2) for indexOf.

// 7. Repeat (1) and (2) for isEmpty.

// 8. Repeat (1) and (2) for size.

// 9. Repeat (1) and (2) for getHead.



//---------------------//
// Doubly linked lists //
//---------------------//
console.log("Doubly linked lists");

// Skip. NOTE: It may be useful to read this section anyway.



//-----------------------//
// Circular linked lists //
//-----------------------//
console.log("Circular linked lists");

// Skip. NOTE: It may be useful to read this section anyway.



//---------//
// Project //
//---------//
console.log("Project");

// 1. Write a function that takes two linked lists as input and returns true if
//    they have the same elements, and false otherwise. Test your code.

function isEqual(list1, list2) {
  // implementation
  function isEqual(list1, list2) {
    // if the lists are different lengths, they're not equal
    if (list1.length !== list2.length) {
        return false;
    }

    // loop through each node in list1 and compare it to the
    // corresponding node in list2
    var current1 = list1.first;
    var current2 = list2.first;
} 

// 2. Implement the stack data structure using a linked list instead of an
//    array. Use the prototype.
function Stack() {
        this.first = null;
        this.length = 0;
    }

    Stack.prototype.push = function(item) {
        // create a new node with the given item
        var newNode = {
            item: item,
            next: null
        };

        // if the stack is empty, make the new node the first node
        if (this.first === null) {
            this.first

function Stack() {
  // put properties here (the linked list)
  // do NOT use this.items = [];
}

// add methods through the prototype



</script>
</head>
<body>
  See console!
</body>
</html>
