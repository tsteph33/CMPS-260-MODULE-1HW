<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 9 Homework</title>
<style>* { font-family: monospace; }</style>
<script>
//-------------------------//
// The tree data structure //
//-------------------------//
console.log("The tree data structure");

// Skip.



//------------------//
// Tree terminology //
//------------------//
console.log("Tree terminology");

// Skip.



//------------------------------------//
// The binary and binary search trees //
//------------------------------------//
console.log("The binary and binary search trees");

function Node(key) {
  this.key = key;
  this.left = null;
  this.right = null
}

function BinarySearchTree() {
  // the root node
  this.root = null;
}

// helper functions
BinarySearchTree.prototype._insertNode = function(node, newNode) {
  // node is the node we want to insert into
  // newNode is the node we want to insert
  if (newNode.key < node.key) {
    // go to left
    if (node.left === null) {
      // no left node yet so assign
      node.left = newNode;
    }
    else {
      // move down tree and repeat
      this._insertNode(node.left, newNode);
    }
  }
  else {
    // go to right
    if (node.right === null) {
      // no right node yet so assign
      node.right = newNode;
    }
    else {
      // move down tree and repeat
      this._insertNode(node.right, newNode);
    }
  }
}

BinarySearchTree.prototype.insert = function(key) {
  // insert new key in the tree
  var newNode = new Node(key);
  if (root === null) {
    // no nodes yet
    root = newNode;
  }
  else {
    // find insert location through insertNode
    this._insertNode(root, newNode);
  }
};

// 1. Finish the implementation of the tree data structure above using the
//    prototype (as opposed to the version we wrote in class). Note that we
//    have helper functions that we have to deal with, and we simply make them
//    part of the prototype but prepend them with _, e.g., _insertNode above.
//    This is a common convention/solution. Programmers using a tree object are
//    not supposed to use _ methods (or properties) directly.
tree.prototype.addChild = function(value){
  var node = {
    value: value,
    parent: this,
    children: []
  };

  this.children.push(node);
};
// 2. Run some tests that show that your code works.
tree.prototype.addChild = function(value){
  var node = {
    value: value,
    parent: this,
    children: []
  };

  this.children.push(node);
};

tree.prototype.contains = function(target){
  if(this.value === target){
    return true;
  }

  for(var i = 0; i < this.children.length; i++


//----------------//
// Tree traversal //
//----------------//
console.log("Tree traversal");

function printNode(value) {
  console.log(value);
}

// 1. Implement in-order traversal using the prototype. Test your
//    implementation with the printNode() function given above.
//    NOTE: in-order means all keys are visited in sorted order.
function TreeNode(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

TreeNode.prototype.inOrderTraverse = function(callback) {
  if (this.left) {
    this.left.inOrderTraverse(callback);
  }

  callback(this.value);

  if (this.right) {
    this.right.
// 2. Implement pre-order traversal using the prototype. Test your
//    implementation with the printNode() function given above.
//    NOTE: pre-order means a node is visited prior to its descendants.
function TreeNode(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

TreeNode.prototype.preOrderTraverse = function(callback) {
  callback(this.value);

  if (this.left) {
    this.left.preOrderTraverse(callback);
  }

  if (this.right) {
    this.right.
// 3. Implement post-order traversal using the prototype. Test your
//    implementation with the printNode() function given above.
//    NOTE: pre-order means a node is visited after its descendants.
function TreeNode(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

TreeNode.prototype.postOrderTraverse = function(callback) {
  if (this.left) {
    this.left.postOrderTraverse(callback);
  }

  if (this.right) {
    this.right.postOrderTraverse(callback);


//--------------------------------//
// Searching for values in a tree //
//--------------------------------//
console.log("Searching for values in a tree");

// 1. Implement the min method using the prototype and show that it works.
Array.prototype.min = function() {
  return Math.min.apply(null, this);
};

console.log([1, 2, 3].min()); // 1
// 2. Implement the max method using the prototype and show that it works.
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};

console.log([1, 2, 3].max()); // 3
// 3. Implement the search method using the prototype and show that it works.
var search = function(text) {
  return this.indexOf(text) !== -1;
};

String.prototype.search = search;

console.log("Hello world!".search("world")); // true
// 4. Implement the remove method using the prototype and show that it works.
var remove = function(text) {
  return this.replace(text, "");
};

String.prototype.remove = remove;

console.log("Hello world!".remove("world")); // Hello !
// Skip.



//----------------------//
// Self-balancing trees //
//----------------------//
console.log("Self-balancing trees");

// Skip.



//---------//
// Project //
//---------//
console.log("Project");

// 1. Create the tree that is given in the book if you haven't done so yet.
//    NOTE: Use the one given right before the Tree Traversal section that
//          includes the 6.

// 2. We want to make a copy of this tree, but want to make sure that the copy
//    we create is also nicely balanced (since we did not implement AVL). We
//    can use in-order, pre-order, and post-order traversal to retrieve the
//    nodes. If we want the new tree to be balanced as well, which order should
//    we use if we want to insert the nodes in the new tree?

// 3. Run the traversal approach you picked in (2) to collect all the keys and
//    store them in an array.

// 4. Iterate through the array and insert each element inside a new tree. make
//    sure it is balanced.



</script>
</head>
<body>
  See console!
</body>
</html>
